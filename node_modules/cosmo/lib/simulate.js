
utility = require('./utility');
exports = module.exports;

exports.prepareSimulation = function(req,res)
{
	CreateLandmass(req);
	CreateOcean(req, req.area * 5); //  Each tile would get 25
    SetSunlight(req);
    res(null);
};

function CreateLandmass(ctx)
{
    var continentMap = new Array(ctx.area);
    for(var z = 0 ; z < ctx.area; z++) { 
        continentMap[z]=0;
    }
    
    for (var c = 0; c < 3; c++)
    {
        //  Create continent height
        var centerContinentX = -1;
        var centerContinentY = -1;

        while (centerContinentX == -1 || centerContinentY == -1)
        {
            var attemptedX = (ctx.columns / 2) + utility.randomNumberBetween(-ctx.columns / 4, ctx.columns / 4);
            var attemptedY = (ctx.rows / 2) + utility.randomNumberBetween(-ctx.rows / 4, ctx.rows / 4);
                   
            if (continentMap[ctx.ConvertToZ({f:attemptedX, s: attemptedY})] == 0)
            {
                centerContinentX = attemptedX;
                centerContinentY = attemptedY;
            }
        }

        //How far we venture from the continent to place a blob
        var radius = ((ctx.columns + ctx.rows) / 2) / 6;

        for (var i = 0; i < 5; i++)
        {
            var blobCenter = {
                f:centerContinentX + utility.randomNumberBetween(-radius,radius),
                s:centerContinentY + utility.randomNumberBetween(-radius,radius)};
            
            ctx.WrapCoordinate(blobCenter);
            
            var blob_radius = utility.randomNumberBetween(2,8);
            
            var blobResults = ctx.GetRingOfCoordinates(ctx.ConvertToZ(blobCenter), blob_radius, true);

            for (var p = 0; p < blobResults.length; p++)
            {
                 if(continentMap[blobResults[p]]!=1)
                 {
                    ctx.height[blobResults[p]] += utility.randomNumberBetween(2,5);
                    continentMap[blobResults[p]] = 1;
                    
                }
            }
        }

    }

}
function CreateOcean(ctx,totalWaterRequired)
{
	var numberPillars = 10;
	for (var p = 0; p < numberPillars; p++)
    {
        CreatePillarOfWaterAtZ(ctx, 
            utility.randomNumberBetween(0, ctx.area), 
            totalWaterRequired / numberPillars);
    }
    ResolveWater(ctx);

}
function CreatePillarOfWaterAtZ(ctx, z, unitsOfWater)
{
	ctx.depth[z] += unitsOfWater;
	ctx.unresolvedWater[z] = true;
}
function ResolveWater(ctx)
{
	var isFlat = true;
    var accuracy = 1;//0.005;
    do
    {
        isFlat = true; //  Reset test that ocean is flat

        //  Check each coordinate for weird things
        for (var z = 0; z < ctx.area; z++)
        {
            if (ctx.unresolvedWater[z] == false)
                continue;


            isFlat = false;
            var depth = ctx.depth[z];

            if (depth == 0)
            {
                //  There is no water to resolve
                ctx.unresolvedWater[z] = false;
                continue;
            }

            var height = ctx.height[z];
            var elevation = depth + height;

            var neighbors = ctx.GetNeighbors(z, true);

            var numberPossibleDonees = 0;
            do
            {
                depth = ctx.depth[z];
                elevation = depth + height;

                var steepestSlope = 0;
                var steepestSlopeValue = 0;
                numberPossibleDonees = 0;

                //  Find the steepest slope
                for (var n = 0; n < neighbors.length; n++)
                {
                    var n_index = neighbors[n];

                    var neighborDepth = ctx.depth[n_index];
                    var neighborHeight = ctx.height[n_index];
                    var neighborElevation = neighborDepth + neighborHeight;

                    var slope = elevation - neighborElevation;

                    //  Do we have a downward slow too great?
                    if (slope > accuracy)
                    {
                        numberPossibleDonees++;

                        if (slope > steepestSlopeValue)
                        {
                            steepestSlope = n;
                            steepestSlopeValue = slope;
                        }
                    }

                    //  Do we have an upward slope that is too great?
                    if (slope < -accuracy)
                    {
                        //  If that plot has water then it needs to queue up for it
                        if (neighborDepth > 0)
                        {
                            ctx.unresolvedWater[n_index] = true;
                        }
                    }
                }

                if (numberPossibleDonees >= 1)
                {
                    //  There was at least one downward slope that was too great

                    var n_index = neighbors[steepestSlope];
                    ctx.unresolvedWater[n_index] = true;

                    //  Can we pass half our height difference
                    if (ctx.depth[z] > (steepestSlopeValue / 2))
                    {
                        //  Yes we can
                        ctx.depth[z] -= (steepestSlopeValue / 2);
                        ctx.depth[n_index] += (steepestSlopeValue / 2);
                    }
                    else
                    {
                        //  No we cant give enoguht to level them so we give all instead
                        ctx.depth[z] = 0;
                        ctx.depth[n_index] += ctx.depth[z];
                    }


                }
                else
                {
                    //  There was nothing to put out so 
                    ctx.unresolvedWater[z] = false;
                }
            }
            //If we had more than one possibility than we can try again
            while (numberPossibleDonees > 1 && ctx.depth[z] > 0);
        }

    }
    while (isFlat == false);
}

function SetSunlight(ctx)
{
    var equator = Math.round(ctx.rows * ctx.tilt);

    var minSunlight = 1;
    var maxSunlight = 100;

    var distanceBeforeTundra = Math.round(ctx.rows / 1.6);

    var lightOnRow = 0;

    for (var y = 0; y < ctx.rows; ++y)
    {
        //  Determining sunlight value
        var distanceToEquator = Math.abs(equator - y);
        
        
        if (distanceToEquator > distanceBeforeTundra)
        {
            lightOnRow = minSunlight;
        }
        else if (distanceToEquator == 0)
        {
            lightOnRow = maxSunlight;
        }
        else
        {
            var lightRatio =1-( distanceToEquator / distanceBeforeTundra);
            lightOnRow = Math.round((maxSunlight-minSunlight) * lightRatio);
        }

        //  Setting sunlight value
        for (var x = 0; x < ctx.columns; ++x)
        {
            ctx.sunlight[ctx.ConvertToZ({f:x, s:y})] = lightOnRow;
        }
    }
}
// public void EstimateRainfall()
// {
//     List<var> temperature = new List<var>(new var[ctx.prv.totalSize]);
//     List<var> moisture = new List<var>(new var[ctx.prv.totalSize]);

//     List<var> pending_temperature = new List<var>(new var[ctx.prv.totalSize]);
//     List<var> pending_moisture = new List<var>(new var[ctx.prv.totalSize]);

//     //  Creating the wind!
//     for (var m = 0; m < ctx.prv.totalSize; m++)
//     {
//         moisture[m] = 5;

//         temperature[m] = ctx.prv.sunlight[m];

//         pending_moisture[m] = 0;
//         pending_temperature[m] = 0;
//     }

//     //  Setting wind direction to opposite of earth direction
//     var earth_direction = -1;

//     //  TODO: read rotation direction
//     //if (ctx.prv.tilt ==  RotationDirection.EAST_TO_WEST)
//     //{
//     //    earth_direction = 1;
//     //}

//     for (var q = 0; q < 1000; q++)
//     {
//         //  Clear pending changes
//         for (var m = 0; m < ctx.prv.totalSize; m++)
//         {
//             pending_moisture[m] = 0;
//             pending_temperature[m] = 0;
//         }

//         //  Collecting temperature and moisture from environment
//         for (var m = 0; m < ctx.prv.totalSize; m++)
//         {
//             //  Moisture
//             if (ctx.prv.depth[m] > 0.0)
//             {
//                 //  Gain moisture from ocean 
//                 if (rand.Next(0, 100) > 60) moisture[m]++;
//                 if (moisture[m] > 10) moisture[m] = 10;
//             }
//             else
//             {
//                 //  And losing it to land
//                 moisture[m] -= 2;
//                 if (rand.Next(0, 100) > 60) moisture[m]--;
//                 if (moisture[m] < 0) moisture[m] = 0;
//             }

//             //  Temperature
//             if (ctx.prv.sunlight[m] > temperature[m])
//             {
//                 //  Gaining temperature from sunlight
//                 temperature[m]++;
//                 moisture[m]++;
//                 if (temperature[m] > 10) temperature[m] = 10;
//             }
//             else
//             {
//                 temperature[m] -= 2;
//                 if (temperature[m] < 0) temperature[m] = 0;
//             }

//             //  Artic regions killing moisture
//             if (temperature[m] <= 1)
//             {
//                 moisture[m] -= 3;
//                 if (moisture[m] < 0) moisture[m] = 0;
//             }
//             else if (temperature[m] <= 3)
//             {
//                 moisture[m] -= 2;
//                 if (moisture[m] < 0) moisture[m] = 0;
//             }

//         }
//         //  Moving wind!
//         for (var m = 0; m < ctx.prv.totalSize; m++)
//         {
//             Vector2i next_coordinate = ctx.prv.GetCoordinate(m + earth_direction);
//             var nc = ctx.prv.GetCoordinate((var)next_coordinate.f, (var)next_coordinate.s);

//             Vector2i up_coordinate = new Vector2i(next_coordinate.f, next_coordinate.s - 1);
//             var uc = ctx.prv.GetCoordinate((var)up_coordinate.f, (var)up_coordinate.s);

//             Vector2i down_coordinate = new Vector2i(next_coordinate.f, next_coordinate.s + 1);
//             var dc = ctx.prv.GetCoordinate((var)down_coordinate.f, (var)down_coordinate.s);

//             if (temperature[m] > pending_temperature[nc]
//                 &&
//                 moisture[m] > pending_moisture[nc])
//             {
//                 pending_temperature[nc] = temperature[m]++;
//                 pending_moisture[nc] = moisture[m]++;
//             }
//             if (temperature[m] > pending_temperature[uc]
//                 &&
//                 moisture[m] > pending_moisture[uc])
//             {
//                 pending_temperature[uc] = temperature[m]++;
//                 pending_moisture[uc] = moisture[m]++;
//             }
//             if (temperature[m] > pending_temperature[dc]
//                 &&
//                 moisture[m] > pending_moisture[dc])
//             {
//                 pending_temperature[dc] = temperature[m]++;
//                 pending_moisture[dc] = moisture[m]++;
//             }
//         }

//         //  Applying pending changes to 
//         for (var m = 0; m < ctx.prv.totalSize; m++)
//         {
//             temperature[m] = pending_temperature[m];
//             moisture[m] = pending_moisture[m];
//         }
//     }
//     //  Applying the final moisture
//     ctx.prv.wettest = 0;
//     for (var m = 0; m < ctx.prv.totalSize; m++)
//     {
//         ctx.prv.rainfall[m] = moisture[m];
//         if (ctx.prv.rainfall[m] > ctx.prv.wettest) ctx.prv.wettest = ctx.prv.rainfall[m];
//     }

// }