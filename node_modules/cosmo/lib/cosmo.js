'use strict';

//var context = require('./context');
var utility = require('./utility');
var context = require('./context');
exports = module.exports;

var requests = new Array();
var simulations = new Array();

exports.queueSimulationRequest = function(request,res) {
    if(request.name && request.years)
    {
        if(request.years >= 1 && request.years <= 100 )
        {
            //  Do we have that simulation?
            for(var i = 0 ; i < simulations.length; i++) {
                if(request.name == simulations[i].name) 
                {
                    requests.push(request);
                    res(null,requests);
                    return;
                }
            }

            res("We do not have a simulation called " + 
                request.name + ".", requests);
        }
        else
        {
            res(request.name + " cannot be simulated for " + request.years + ". Year values must be between 1 and 100 inclusive.", requests);
        }
    }
    else 
    {
        res("Bad or missing request data.",requests);
    }
};

exports.deleteSimulationRequestsForWorld = function(request,res) {
    
    for(var i = requests.length-1; i >= 0; --i) {
        var item = requests[i];
        console.log(item);
        console.log(request);

        if(item.name == request.name) {
            requests.splice(i, 1);
        }
    }
    res(null,requests);
};

exports.getSimulationRequests = function(res) {
    res(null,requests);
};

exports.clearSimulationRequests = function(res) {
    requests = new Array();
    res(null,requests);
};
exports.processSimulationRequests = function(res)
{
    for(var r = 0 ; r < requests.length; r++) 
    {
        for(var s = 0 ; s < simulations.length ; s++)
        {
            if(requests[r].name == simulations[s].name) 
            {
                //  Actually simulate this


                //console.log("" + simulations[s].year+"+"+requests[r].years);
                simulations[s].year += requests[r].years;
            }
        }
    }
    requests = new Array();
    res(null,
        {
            requests:requests,
            simulations:simulations
        });
};

exports.createSimulation = function(req, res) {
    var newSimulation = context.createContext(req.name, 100, 180, 0.5, 0);
    console.log(newSimulation);
    simulations.push(newSimulation);
    res(null,simulations);
};
exports.deleteSimulation = function(req,res) {
    for(var i = simulations.length-1; i >= 0; --i) {
        var item = simulations[i];

        if(item.name == req) {
            simulations.splice(i, 1);
        }
    }
    res(null,simulations);
};
exports.clearSimulations = function(res) {
    simulations= new Array();
    res(null,simulations);
};
exports.getSimulations = function(res) {
    res(null,simulations);
};


// var unresolvedWater;

// function CreateSimulation(ctx)
// {
// 	CreateLandmass();
// 	CreateOcean(ctx.area * fillToDepth); //  Each tile would get 25
// }

// function CreatingLandmass()
// {
//     for (var c = 0; c < 3; c++)
//     {
//         //  Create continent height

//         var centerContinentX = -1;
//         var centerContinentY = -1;

//         while (centerContinentX == -1 || centerContinentY == -1)
//         {
//             var attemptedX = (ctx.numberColumns / 2) + RandomNumberBetween(-ctx.numberColumns / 4, ctx.numberColumns / 4);
//             var attemptedY = (ctx.numberRows / 2) + RandomNumberBetween(-ctx.numberRows / 3, ctx.numberRows / 3);

//             if (continentMap[ctx.GetCoordinate(attemptedX, attemptedY)] == 0)
//             {
//                 centerContinentX = attemptedX;
//                 centerContinentY = attemptedY;
//             }
//         }

//         //How far we venture from the continent to place a blob
//         var radius = ((ctx.numberColumns + ctx.numberRows) / 2) / 6;

//         for (var i = 0; i < 3; i++)
//         {
//             var blobX = centerContinentX - (radius / 2) + (RandomNumberBetween(radius));
//             var blobY = centerContinentY - (radius / 2) + (RandomNumberBetween(radius));
//             var blob_radius = radius / (RandomNumberBetween(3) + 1);

//             var blobResults = ctx.GetRingOfCoordinates(blobX, blobY, blob_radius, true);

//             for (var p = 0; p < blobResults.Count; p++)
//             {
//                 ctx.height[blobResults[p]] = fillToDepth + 5;
//             }
//         }
//     }
// }
// function CreateOcean(totalWaterRequired)
// {
// 	var numberPillars = 10;
// 	for (var p = 0; p < numberPillars; p++)
//     {
//         var pillarZ = -1;

//         while (pillarZ == -1)
//         {
//             var attemptedZ = RandomNumberBetween(0, ctx.totalSize);

//             if (continentMap[attemptedZ] == 0)
//             {
//                 pillarZ = attemptedZ;
//             }
//         }

//         CreatePillarOfWaterAtZ(z, totalWaterRequired /numberPillars);
//     }	

//     ResolveWater();
// }
// function CreatePillarOfWaterAtZ(z, unitsOfWater)
// {
// 	ctx.depth[z] += unitsOfWater;
// 	unresolvedWater[z] = true;
// }
// function ResolveWater()
// {
// 	var isFlat = true;
//     var accuracy = 0;//0.05;//0.005;

//     do
//     {
//         isFlat = true; //  Reset test that ocean is flat

//         //  Check each coordinate for weird things
//         for (var z = 0; z < ctx.area; z++)
//         {
//             if (unresolvedWater[z] == false)
//                 continue;

//             var depth = ctx.depth[z];

//             if (depth == 0)
//             {
//                 //  There is no water to resolve
//                 unresolvedWater[z] = true;
//                 continue;
//             }

//             var height = ctx.height[z];
//             var elevation = depth + height;

//             var neighbors = ctx.GetNeighbors(z, false);

//             var numberPossibleDonees = 0;
//             do
//             {
//                 depth = ctx.depth[z];
//                 elevation = depth + height;

//                 var steepestSlope = 0;
//                 var steepestSlopeValue = 0;
//                 numberPossibleDonees = 0;

//                 //  Find the steepest slope
//                 for (var n = 0; n < neighbors.length; n++)
//                 {
//                     var n_index = neighbors[n];

//                     var neighborDepth = ctx.depth[n_index];
//                     var neighborHeight = ctx.height[n_index];
//                     var neighborElevation = neighborDepth + neighborHeight;

//                     var slope = elevation - neighborElevation;

//                     //  Do we have a downward slow too great?
//                     if (slope > accuracy)
//                     {
//                         numberPossibleDonees++;

//                         if (slope > steepest_slope_value)
//                         {
//                             steepest_slope = n;
//                             steepest_slope_value = slope;
//                         }
//                     }

//                     //  Do we have an upward slope that is too great?
//                     if (slope < -accuracy)
//                     {
//                         //  If that plot has water then it needs to queue up for it
//                         if (neighborDepth > 0)
//                         {
//                             unresolvedWater[n_index] = true;
//                         }
//                     }
//                 }

//                 if (numberPossibleDonees >= 1)
//                 {
//                     //  There was at least one downward slope that was too great

//                     var n_index = neighbors[steepest_slope];
//                     unresolvedWater[n_index] = true;

//                     //  Can we pass half our height difference
//                     if (ctx.depth[z] > (steepest_slope_value / 2))
//                     {
//                         //  Yes we can
//                         ctx.depth[z] -= (steepest_slope_value / 2);
//                         ctx.depth[n_index] += (steepest_slope_value / 2);
//                     }
//                     else
//                     {
//                         //  No we cant give enoguht to level them so we give all instead
//                         ctx.depth[n_index] += ctx.depth[z];
//                         ctx.depth[z] = 0;
//                     }


//                 }
//                 else
//                 {
//                     //  There was nothing to put out so 
//                     unresolvedWater[z] = false;
//                 }
//             }
//             //If we had more than one possibility than we can try again
//             while (numberPossibleDonees > 1 && ctx.depth[z] > 0);
//         }

//     }
//     while (isFlat == false);
// }

/*var ctx = new Context("babo", 80  , 50, 0.5f, 1,5,5);

var unresolvedWater;

function RandomNumberBetween(inclusive, exclusive)
{
    return ((exclusive-inclusive)*Math.random()) + inclusive;
}

module.cosmo = {
    CreateSimulation: function (ctx) {

        CreateLandmass();
        CreateOcean(ctx.area * fillToDepth); 
    },
    CreateLandmass: function() {
        
        for (var c = 0; c < 3; c++)
        {
            //  Create continent height

            var centerContinentX = -1;
            var centerContinentY = -1;

            while (centerContinentX == -1 || centerContinentY == -1)
            {
                var attemptedX = (ctx.numberColumns / 2) + RandomNumberBetween(-ctx.numberColumns / 4, ctx.numberColumns / 4);
                var attemptedY = (ctx.numberRows / 2) + RandomNumberBetween(-ctx.numberRows / 3, ctx.numberRows / 3);

                if (continentMap[ctx.GetCoordinate(attemptedX, attemptedY)] == 0)
                {
                    centerContinentX = attemptedX;
                    centerContinentY = attemptedY;
                }
            }

            //How far we venture from the continent to place a blob
            var radius = ((ctx.numberColumns + ctx.numberRows) / 2) / 6;

            for (var i = 0; i < 3; i++)
            {
                var blobX = centerContinentX - (radius / 2) + (RandomNumberBetween(radius));
                var blobY = centerContinentY - (radius / 2) + (RandomNumberBetween(radius));
                var blob_radius = radius / (RandomNumberBetween(3) + 1);

                var blobResults = ctx.GetRingOfCoordinates(blobX, blobY, blob_radius, true);

                for (var p = 0; p < blobResults.Count; p++)
                {
                    ctx.height[blobResults[p]] = fillToDepth + 5;
                }
            }
        }
    },
    CreateOcean: function(totalWaterRequired) {
        var numberPillars = 10;
        for (var p = 0; p < numberPillars; p++)
        {
            var pillarZ = -1;

            while (pillarZ == -1)
            {
                var attemptedZ = RandomNumberBetween(0, ctx.totalSize);

                if (continentMap[attemptedZ] == 0)
                {
                    pillarZ = attemptedZ;
                }
            }

            CreatePillarOfWaterAtZ(z, totalWaterRequired /numberPillars);
        }   

        ResolveWater();
    },
    CreatePillarOfWaterAtZ: function(z,unitsOfWater) {
        ctx.depth[z] += unitsOfWater;
        unresolvedWater[z] = true;
    },
    ResolveWater: function() {
        var isFlat = true;
        var accuracy = 0;//0.05;//0.005;

        do
        {
            isFlat = true; //  Reset test that ocean is flat

            //  Check each coordinate for weird things
            for (var z = 0; z < ctx.area; z++)
            {
                if (unresolvedWater[z] == false)
                    continue;

                var depth = ctx.depth[z];

                if (depth == 0)
                {
                    //  There is no water to resolve
                    unresolvedWater[z] = true;
                    continue;
                }

                var height = ctx.height[z];
                var elevation = depth + height;

                var neighbors = ctx.GetNeighbors(z, false);

                var numberPossibleDonees = 0;
                do
                {
                    depth = ctx.depth[z];
                    elevation = depth + height;

                    var steepestSlope = 0;
                    var steepestSlopeValue = 0;
                    numberPossibleDonees = 0;

                    //  Find the steepest slope
                    for (var n = 0; n < neighbors.length; n++)
                    {
                        var n_index = neighbors[n];

                        var neighborDepth = ctx.depth[n_index];
                        var neighborHeight = ctx.height[n_index];
                        var neighborElevation = neighborDepth + neighborHeight;

                        var slope = elevation - neighborElevation;

                        //  Do we have a downward slow too great?
                        if (slope > accuracy)
                        {
                            numberPossibleDonees++;

                            if (slope > steepest_slope_value)
                            {
                                steepest_slope = n;
                                steepest_slope_value = slope;
                            }
                        }

                        //  Do we have an upward slope that is too great?
                        if (slope < -accuracy)
                        {
                            //  If that plot has water then it needs to queue up for it
                            if (neighborDepth > 0)
                            {
                                unresolvedWater[n_index] = true;
                            }
                        }
                    }

                    if (numberPossibleDonees >= 1)
                    {
                        //  There was at least one downward slope that was too great

                        var n_index = neighbors[steepest_slope];
                        unresolvedWater[n_index] = true;

                        //  Can we pass half our height difference
                        if (ctx.depth[z] > (steepest_slope_value / 2))
                        {
                            //  Yes we can
                            ctx.depth[z] -= (steepest_slope_value / 2);
                            ctx.depth[n_index] += (steepest_slope_value / 2);
                        }
                        else
                        {
                            //  No we cant give enoguht to level them so we give all instead
                            ctx.depth[n_index] += ctx.depth[z];
                            ctx.depth[z] = 0;
                        }


                    }
                    else
                    {
                        //  There was nothing to put out so 
                        unresolvedWater[z] = false;
                    }
                }
                //If we had more than one possibility than we can try again
                while (numberPossibleDonees > 1 && ctx.depth[z] > 0);
            }

        }
        while (isFlat == false);
    }
};
*/

