exports = module.exports;

exports.createContext = function(name, columns, rows, myTilt, myRotationDirection) 
{
    var ctx = {};
    ctx.name = name;
    
    ctx.columns = columns;
    ctx.rows = rows;
    ctx.area = rows * columns;

    ctx.tilt = myTilt;
    ctx.rotationDirection = myRotationDirection;

    ctx.day = 1;
    ctx.month = 1;
    ctx.year = 0;

    ctx.highest = 1;
    ctx.hottest = 1;
    ctx.deepest = 1;
    ctx.brighest = 1;
    ctx.wettest = 1;

    ctx.plantColumns = ctx.columns * 1;
    ctx.plantRows = ctx.rows * 1;
    ctx.plantArea = ctx.plantColumns * ctx.plantRows;

    ctx.tectonic = new Array(ctx.area);
    ctx.heat = new Array(ctx.area);
    ctx.height = new Array(ctx.area);
    ctx.depth = new Array(ctx.area);
    ctx.sunlight = new Array(ctx.area);
    ctx.rainfall = new Array(ctx.area);

    //  PLOT DATA  //
    ctx.soilNucium = new Array(ctx.plantArea);
    ctx.soilNutro = new Array(ctx.plantArea);

    //  Plant data
    ctx.deadPlant = new Array(ctx.plantArea);
    ctx.nuciumStore = new Array(ctx.plantArea);
    ctx.nutroStore = new Array(ctx.plantArea);
    ctx.waterStore = new Array(ctx.plantArea);

    for(var z = 0 ; z < ctx.area; z++)
    {   
        ctx.tectonic[z] = 0;//-1;
        ctx.heat[z] = 0;

        ctx.height[z] = 3;// + RandomNumberBelow(5);
        ctx.depth[z] = 0;

        ctx.sunlight[z] = 10;
        ctx.rainfall[z] = 5;
    }

    //  Initializing plots
    for(var p = 0 ; p < ctx.plantArea; p++)
    {
        ctx.soilNutro[p] = 5;
        ctx.soilNucium[p] = 5;

        ctx.deadPlant[p] = true;
        ctx.nuciumStore[p] = 0;
        ctx.nutroStore[p] = 0;
        ctx.waterStore[p] = 0;
    }
    ctx.ConvertToZ = function(coord)
    {
        return WrapCoordinate(coord.f + ctx.columns * coord.s);
    };
    ctx.ConvertToCoord = function(z)
    {
        return { f: z % ctx.columns, s: z / ctx.columns };
    };

    ctx.WrapCoordinate = function(coord)
    {
        while (coord.f < 0)
        {
            coord.f += ctx.columns;
        }
        while (coord.f >= numberColumns)
        {
            coord.f -= ctx.columns;
        }

        while (coord.s < 0)
        {
            coord.s += ctx.rows;
        }
        while (coord.s >= numberRows)
        {
            coord.s -= ctx.columns;
        }

        return coord;
    };

    ctx.WrapZ = function(z) {
        while(z<0) {z += ctx.area;}
        while(z>=ctx.area) {z -= ctx.area;}
     };

    ctx.GetNeighbors = function(z, includeDiagonals)
    {
        var neighbors = new Array();

        neighbors.push(WrapZ(z+1));
        neighbors.push(WrapZ(z-1));
        neighbors.push(WrapZ(z - ctx.columns));
        neighbors.push(WrapZ(z + ctx.columns));

        if (includeDiagonals)
        {
            neighbors.push(WrapZ(z+1 - ctx.columns));
            neighbors.push(WrapZ(z-1 - ctx.columns));
            neighbors.push(WrapZ(z+1 + ctx.columns));
            neighbors.push(WrapZ(z-1 + ctx.columns));   
        }

        return neighbors;
    };


    ctx.GetRingOfCoordinates = function(z, radius, doGetCenter)
    {
        var ring = new Array();

        //  Handle center
        if (myDoGetCenter)
        {
            ring.push(Wrap(z));
        }
        //  Spokes
        for (var r = 1; r <= myRadius; r++)
        {
            ring.push(WrapZ(z+r));
            ring.push(WrapZ(z-r));
            ring.push(WrapZ(z+(r*ctx.columns)));
            ring.push(WrapZ(z-(r*ctx.columns)));
        }

        var coord = ConvertToCoord(z);

        //  Pie slices
        for (var r = myRadius; r > 0; r--)
        {
            var x = coord.s + 1;
            var y = coord.f - r + 1;

            while (x > coord.s)
            {
                if (y != myStartingY)
                {
                    ring.push(ConvertToZ({f:x, s:y}));
                }

                if (y < myStartingY)
                {
                    x++;
                }
                else
                {
                    x--;
                }

                y++;
            }
            x--;
            y--;
            while (x < coord.s)
            {
                if (y != coord.s)
                {
                    ring.push(ConvertToZ({f:x, s:y}));
                }

                if (y > myStartingY)
                {
                    x--;
                }
                else
                {
                    x++;
                }

                y--;
            }
        }
        return ring;
    
    };
    return ctx;
};
