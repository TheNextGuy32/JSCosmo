'use strict';

exports = module.exports;

var cmyk_to_hex = require( "colorvert/cmyk/hex" );

var shallowestOcean = {c:42,m:21,y:0,k:1};
var deepestOcean = {c:70,m:30,y:0,k:63};

var lowestValley = {c:0,m:11,y:32,k:71};
var tallestMountain = {c:0,m:10,y:30,k:4};

var darkest = {c:0,m:12,y:41,k:16};
var brightest ={c:0,m:1,y:20,k:5};

exports.render = function(req,res)
{
	calculateHighestAndLowest(req.ctx);

	var colors = new Array(req.ctx.area);
	if(req.mode == "Depth")
	{
		for(var z = 0 ; z < req.ctx.area ; z++)
		{
			if(req.ctx.depth[z]>1)
			{
				colors[z] = colorizeWater(req.ctx.depth[z],req.ctx);
			}
			else
			{
				colors[z] = colorizeEarth(0,req.ctx);
			}
		}
	}
	else if (req.mode == "Height")
	{
		for(var z = 0 ; z < req.ctx.area ; z++)
		{
			//console.log(req.ctx.height[z]);
			colors[z] = colorizeEarth(req.ctx.height[z],req.ctx);
		}
	}
	else if (req.mode == "Satellite")
	{
		for(var z = 0 ; z < req.ctx.area ; z++)
		{
			if(req.ctx.depth[z]>1)
			{
				colors[z] = colorizeWater(req.ctx.depth[z],req.ctx);
			}
			else
			{
				colors[z] = colorizeEarth(req.ctx.height[z],req.ctx);
			}
		}
	}
	else if (req.mode == "Satellite")
	{
		for(var z = 0 ; z < req.ctx.area ; z++)
		{
			colors[z] = colorizeEarth(req.ctx.height[z],req.ctx);
		}
	}
	else if (req.mode == "Elevation")
	{
		for(var z=0; z < req.ctx.area; z++)
		{
			colors[z] = colorizeElevation(req.ctx.height[z] + req.ctx.depth[z],req.ctx);
		}
	}
	else if (req.mode == "Sunlight")
	{
		for(var z=0; z < req.ctx.area; z++)
		{
			colors[z] = colorizeSunlight(req.ctx.sunlight[z],req.ctx);
		}
	}
	else {
		res(req.mode + " doesn't exist.");
		return;
	}

	res(null, colors);
};
function colorValueBetween (value,minValue,maxValue,bottomColor,topColor) {
	var ratio = (value-minValue)/(maxValue-minValue);

	var deltaColor = {
		c:bottomColor.c-topColor.c,
		m:bottomColor.m-topColor.m,
		y:bottomColor.y-topColor.y,
		k:bottomColor.k-topColor.k
	};

	var newColor = {
		c: Math.round(bottomColor.c - (deltaColor.c*ratio)),
		m: Math.round(bottomColor.m - (deltaColor.m*ratio)),
		y: Math.round(bottomColor.y - (deltaColor.y*ratio)),
		k: Math.round(bottomColor.k - (deltaColor.k*ratio))
	};
	
	//console.log(newColor);
	
    var c = newColor.c / 100;
    var m = newColor.m / 100;
    var y = newColor.y / 100;
    var k = newColor.k / 100;
	
	var result = {};
    result.r = 1 - Math.min( 1, c * ( 1 - k ) + k );
    result.g = 1 - Math.min( 1, m * ( 1 - k ) + k );
    result.b = 1 - Math.min( 1, y * ( 1 - k ) + k );

    return rgbToHex(
    	Math.round( result.r * 255 ), 
    	Math.round( result.g * 255 ), 
    	Math.round( result.b * 255 ));
}

function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}


function calculateHighestAndLowest(ctx)
{
	ctx.highest = 1;
    ctx.hottest = 1;
    ctx.deepest = 1;
    ctx.brightest = 1;
    ctx.wettest = 1;
    ctx.tallest = 1;

    for(var z = 0 ; z < ctx.area ; z++)
	{
		if(ctx.height[z] > ctx.highest)
		{
			ctx.highest = ctx.height[z];
		}
		if(ctx.heat[z] > ctx.hottest)
		{
			ctx.hottest = ctx.heat[z];
		}
		if(ctx.depth[z] > ctx.deepest)
		{
			ctx.deepest = ctx.depth[z];
		}
		if(ctx.sunlight[z] > ctx.brightest)
		{
			ctx.brightest = ctx.sunlight[z];
		}
		if(ctx.rainfall[z] > ctx.wettest)
		{
			ctx.wettest = ctx.rainfall[z];
		}
		if(ctx.height[z] + ctx.depth[z] > ctx.tallest)
		{
			ctx.tallest = ctx.height[z] + ctx.depth[z];
		}
	}
}
function colorizeSunlight(value,ctx)
{
	//console.log(ctx.brightest);
	return colorValueBetween(value,1,ctx.brightest,darkest,brightest);	
}
function colorizeElevation(value,ctx)
{
	return colorValueBetween(value,0,ctx.tallest,lowestValley,tallestMountain);	
}
function colorizeEarth(value,ctx)
{
	return colorValueBetween(value,0,ctx.highest,lowestValley,tallestMountain);
}
function colorizeWater(value,ctx)
{
	return colorValueBetween(value,0,ctx.deepest,shallowestOcean,deepestOcean);
}
